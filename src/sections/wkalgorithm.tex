\section{$Wk$-algorithm}

%TODO translate
Wir wollen nun einen Algorithmus zur Berechnung der getwisteten schwachen
Ordnung $Wk(\theta)$ einer beliebigen Coxetergruppe $W$ erarbeiten. Also
Ausgangspunkt werden wir den Algorithmus aus \cite[Algorithm 3.1.1]{haas:twoa}
verwenden, der im wesentlichen benutzt, dass für jede getwistete Involution $w
\in \ti{\theta}$ entweder $w \ul s < w$ oder aber $w \ul s > w$ gilt.

%TODO translate
\begin{algo}[Algorithmus 1]
	\hfill
	\label{twoa1}
	\begin{algorithmic}[1]
	\Procedure{TwistedWeakOrderingAlgorithm1}{$W$} \Comment{$W$ sei die
	Coxetergruppe}
	\State $V \gets \{(e,0)\}$
	\State $E \gets \{\}$

	\For{$k \gets 0 \textbf{ to } k_{\max}$}
		\ForAll{$(w,k_w) \in V \textbf{ with } k_w = k$}
			\ForAll{$s \in S \textbf{ with } \nexists (\cdot,w,s) \in E$} \Comment{Nur
			die $s$, die nicht schon nach $w$ führen} \State $y \gets ws$
				\State $z \gets \theta(s)y$
				\If{$z=w$}
					\State $x \gets y$ \Comment{s operiert ungetwistet auf w}
					\State $t \gets s$
				\Else
					\State $x \gets z$ \Comment{s operiert getwistet auf w}
					\State $t \gets \ul{s}$
				\EndIf
				
				\State $isNew \gets \textbf{true}$
				\ForAll{$(w',k_{w'}) \in V \textbf{ with } k_{w'} = k+1$} \Comment{Prüfen,
				ob $x$ nicht schon in $V$ liegt}
					\If{$x = w'$}
						\State $isNew \gets \textbf{false}$
					\EndIf
				\EndFor
				
				\If{$isNew = \textbf{true}$}
					\State $V \gets V \cup \{ (x,k+1) \}$
					\State $E \gets E \cup \{ (w,x,t) \}$
				\Else
					\State $E \gets E \cup \{ (w,x,t) \}$
				\EndIf
			\EndFor
		\EndFor
		\State $k \gets k + 1$
	\EndFor

	\State \textbf{return} $(V,E)$\Comment{The poset graph}
	\EndProcedure
	\end{algorithmic}
\end{algo}

%TODO translate
Dieser Algorithmus berechnet alle getwisteten Involutionen und deren
getwistete Länge $(w,k_w)$ und deren Relationen $(w',w,s)$ bzw. $(w',w,\ul
s)$. Zu bemerken ist, dass zur Berechnung der ge\-twis\-te\-ten Involutionen der
Länge $k$ nur die Knoten aus $V$ benötigt werden, mit der getwisteten Länge $k-1$ und $k$ sowie
die Kanten aus $E$, die Knoten der Länge $k-2$ und $k-1$ bzw. $k-1$ und $k$
verbinden. Alle vorherigen Ergebnisse können schon persistiert werden, so dass
nie das komplette Ergebnis im Speicher gehalten werden muss.

Eine Operation, die hier als elementar angenommen wurde ist der Vergleich von
Elementen in $W$. Für bestimmte Gruppen wie z.B. die $A_n$, welche je isomorph
zu $Sym(n+1)$ sind, lässt sich der Vergleich von Element effizient
implementieren. Will man jedoch mit Coxetergruppen im Allgemeinen arbeiten, so
liegt $W$ als frei präsentierte Gruppe vor und der Vergleich von Element is eine
sehr aufwendige Operation. Bei \algoref{twoa1} muss jedes
potentiell neue Element $x$ mit allen schon bekannten $w'$ von gleicher
getwisteter Länge verglichen werden um zu bestimmen, ob $x$ wirklich ein noch
nicht bekanntes Element aus $\ti{\theta}$ ist.

%TODO translate
\begin{algo}[Algorithmus 2]
	\hfill
	\label{twoa2}
	\begin{algorithmic}[1]
	\Procedure{TwistedWeakOrderingAlgorithm2}{$W$} \Comment{$W$ sei die
	Coxetergruppe}
	\State $V \gets \{(e,0)\}$
	\State $E \gets \{\}$

	\For{$k \gets 0 \textbf{ to } k_{\max}$}
		\State TODO
	\EndFor

	\State \textbf{return} $(V,E)$\Comment{The poset graph}
	\EndProcedure
	\end{algorithmic}
\end{algo}

\begin{table}
	\label{benchmark-twoa}
	\centering
	\begin{tabular}{|c|c|c|r|r|r|r|}
	\hline
	\multicolumn{3}{|c|}{} & \multicolumn{2}{|c|}{Timings} &
	\multicolumn{2}{|c|}{Element compares}\\
	\hline
	W & $|Wk(\id,W)|$ & $\rho(w_0)$ & TWOA1 & TWOA2 & TWOA1 & TWOA2\\
	\hline
	$A_9$ & 9496 & 25 & 00:02.180 & 00:01.372 & 13,531,414 & 42,156\\
	\hline
	$A_{10}$ & 35696 & 30 & 00:31.442 & 00:06.276 & 185,791,174 & 173,356\\
	\hline
	$A_{11}$ & 140152 & 36 & 11:04.241 & 00:29.830 & 2,778,111,763 & 737,313\\
	\hline
	$E_6$ & 892 & 20 & 00:03.044 & 00:00.268 & 85,857 & 2,347\\
	\hline
	$E_7$ & 10208 & 35 & 06:11.728 & 00:02.840 & 7,785,186 & 29,687\\
	\hline
	$E_8$ & 199952 & 64 & -- & 11:03.278 & -- & 682,227\\
	\hline
	\end{tabular}
	\caption{Benchmark}
\end{table}

%TODO translate
Im Anhang findet sich eine Implementierung der \algoref{twoa1,twoa2}
in GAP 4.5.4. \tableref{benchmark-twoa} zeigt ein Benchmark anhand von fünf
ausgewählten Coxetergruppen.

%TODO translate
Dabei sind die $A_n$ als
symmetrische Gruppen implementiert und die $E_n$ als frei präsentierte Gruppen.
Ausgeführt wurden die Messungen auf einem Intel Core i5-3570k mit vier Kernen
zu je 3,40 GHz. Der Algorithmus ist dabei aber nur single threaded und kann so
nur auf einem Kern laufen. Um die Messergebnisse nicht durch Limitierungen des
Datenspeichers zu beeinflussen, wurden die Daten in diesem Benchmark nicht
stückweise persistiert sondern ausschließlich berechnet.

Wie zu erwarten ist der Geschwindigkeitsgewinn bei den Coxetergruppen vom Typ
$E_n$ deutlich größer, da in diesem Fall die Elementvergleiche deutlich
aufwendiger sind als bei Gruppen vom Typ $A_n$.