%!TEX root = ../../../_main.tex
\subsection{Implementing the twisted weak ordering algorithms}
\label{sec:implementing-twisted-involutions-algorithms}

\begin{figure}[ht]
	\centering
	\begin{tikzpicture}
		\pgfplotstableread{resources/data/benchmark1.txt} \dataTwoaOne
		\pgfplotstableread{resources/data/benchmark2.txt} \dataTwoaTwo
		\pgfplotstableread{resources/data/benchmark3.txt} \dataTwoaThree
		\begin{axis}[width=0.9\textwidth,legend pos= south east,grid=major,xmode=log,ymode=log,
			xlabel={Size of $Wk(W,\theta)$},ylabel=Runtime in seconds]
			\addplot table[x=numVertices, y=comparisons] from \dataTwoaOne;
			\addlegendentry{TWOA1}
			\addplot table[x=numVertices, y=comparisons] from \dataTwoaTwo;
			\addlegendentry{TWOA2}
			\addplot table[x=numVertices, y=comparisons] from \dataTwoaThree;
			\addlegendentry{TWOA3}
		\end{axis}
	\end{tikzpicture}
	\caption{Element comparisons needed in TWOA1, TWOA2 and TWOA3}
	\label{fig:twoa123-element-comparisons}
\end{figure}

In this section we will look at a concrete implementation of the algorithm \ref{algo:twoa1} from \cite{brennemann:twoa} and \cite{haas:twoa} and of the improvement versions \ref{algo:twoa2} and \ref{algo:twoa3}, that we have just introduced. The source codes can be found in the appendix. It is implemented in GAP\footnote{See \url{http://www.gap-system.org/}.}, a System for Computational Discrete Algebra, Version 4.5.5. It supplies a powerful programming language and can handle with free represented groups, in particular it allows comparisons of elements in such groups. 

At first we compare the count of element comparisons need for our three algorithms. For this we calculate $Wk(W,\id)$ for the Coxeter groups $A_1,\ldots,A_{11}$, $BC_2,\ldots,BC_6$, $D_4,D_5,D_6$, $E_6,E_7,E_8$, $F_4$, $H_3$, $H_4$. In Figure~\ref{fig:twoa123-element-comparisons} we see the plot showing the size $|Wk(W,\id)|$ on the x-axis and the count of needed element comparisons on the y-axis. The first observation is the much lower count of needed element comparisons of \ref{algo:twoa2} and \ref{algo:twoa3} against \ref{algo:twoa1}. As one would expect, this results in much better execution time of the three algorithms, at least for large groups. When comparing the execution time only for the Coxeter groups of type $A_n$, then \ref{algo:twoa1} is ahead for small $n$, since the element comparison in $A_n$, when represented as symmetric group $\Sym(n+1)$ can be done very effectively. Hence the larger costs for avoiding element comparisons, top the savings. As $n$ becomes larger and larger, \ref{algo:twoa1} falls more and more behind. Figure~\ref{fig:twoa123-runtime} show the runtime for $W=A_n$ with $n=1,\dots,11$.

\begin{figure}[ht]
	\centering
	\begin{tikzpicture}
		\pgfplotstableread{resources/data/a-benchmark1.txt} \dataTwoaOne
		\pgfplotstableread{resources/data/a-benchmark2.txt} \dataTwoaTwo
		\pgfplotstableread{resources/data/a-benchmark3.txt} \dataTwoaThree
		\begin{axis}[width=0.9\textwidth,legend pos= south east,grid=major,xmode=log,ymode=log,
			xlabel={Size of $Wk(W,\theta)$},ylabel=Runtime in seconds]
			\addplot table[x=numVertices, y=time] from \dataTwoaOne;
			\addlegendentry{TWOA1}
			\addplot table[x=numVertices, y=time] from \dataTwoaTwo;
			\addlegendentry{TWOA2}
			\addplot table[x=numVertices, y=time] from \dataTwoaThree;
			\addlegendentry{TWOA3}
		\end{axis}
	\end{tikzpicture}
	\caption{Runtime for TWOA1, TWOA2 and TWOA3 in seconds with $W = A_n$}
	\label{fig:twoa123-runtime}
\end{figure}

The algorithms have been executed on a computer running Debian Linux in Verion 6.0.5 with an Intel\textsuperscript{\textregistered} Core\textsuperscript{\texttrademark} i7-965 CPU with four cores at 3.2 GHz and 8 GiB RAM. Since the algorithms cannot be parallized, only one core can be used for running the algorithms.